## 三、变量、作用域和内存问题

#### 1、基本类型和引用类型的值

- 概念
  - 变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象；
  - 基本数据类型：Undefined、Null、Boolean、Number 和 String。这 5 种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值；
  - 引用类型的值是保存在内存中的对象，当复制保存着对象的某个变量时，操作的是对象的引用，但在为对象添加属性时，操作的是实际的对象。

- 动态的属性

  - 定义基本类型值和引用类型值的方式是类似的：创建一个变量并为该变量赋值

  - 对于引用类型的值，可以为其添加属性和方法，也可以改变和删除其属性和方法

    ```js
    var person = new Object();
    person.name = "Nicholas";
    alert(person.name); //"Nicholas"
    ```

  - 不能给基本类型的值添加属性，尽管这样做不会导致任何错误

    ```js
    var name = "Nicholas";
    name.age = 27;
    alert(name.age); //undefined 
    ```

- 复制变量值

  - 如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制
    到为新变量分配的位置上，这两个变量可以参与任何操作而不会相互影响

    ```js
    var num1 = 5;
    var num2 = num1; 
    ```

  - 当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量

    ```js
    var obj1 = new Object();
    var obj2 = obj1;
    obj1.name = "Nicholas";
    alert(obj2.name); //"Nicholas"
    ```

- 传递参数

  - 访问变量有按值和按引用两种方式，而参数只能按值传递（所有函数的参数都是按值传递的），把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样

  - 在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数， 也是arguments 对象中的一个元素）

    ```js
    function addTen(num) {
     	num += 10;
     	return num;
    }
    var count = 20;
    var result = addTen(count);
    alert(count); //20，没有变化
    alert(result); //30 
    ```

  - 在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部

    ```js
    //例1：
    function setName(obj) {
     	obj.name = "Nicholas";
    }
    var person = new Object();
    setName(person);
    alert(person.name); //"Nicholas"
    //例2：
    function setName(obj) {
     	obj.name = "Nicholas";
     	obj = new Object();
     	obj.name = "Greg";
    }
    var person = new Object();
    setName(person);
    alert(person.name); //"Nicholas" 
    ```

- 检测类型

  - `typeof` 操作符

    ```js
    //typeof 操作符是确定一个变量是字符串、数值、布尔值，还是 undefined 的最佳工具
    //如果变量的值是一个对象或 null，则 typeof 操作符会返回"object"
    //使用 typeof 操作符检测函数时，该操作符会返回"function"
    var s = "Nicholas";
    var b = true;
    var i = 22;
    var u;
    var n = null;
    var o = new Object();
    alert(typeof s); //string
    alert(typeof i); //number
    alert(typeof b); //boolean
    alert(typeof u); //undefined
    alert(typeof n); //object
    alert(typeof o); //object 
    ```

  - `instanceof `操作符

    ```js
    //在检测一个引用类型值和 Object 构造函数时，instanceof 操作符始终会返回 true
    //如果使用 instanceof 操作符检测基本类型的值，则该操作符始终会返回 false
    alert(person instanceof Object); // 变量 person 是 Object 吗？
    alert(colors instanceof Array); // 变量 colors 是 Array 吗？
    alert(pattern instanceof RegExp); // 变量 pattern 是 RegExp 吗？
    ```

#### 2、执行环境及作用域

- 概念

  - **执行环境**（execution context，也称为“环境”）定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁；

  - **全局执行环境**是最外围的一个执行环境，宿主环境不同，表示执行环境的对象也不一样，在 Web 浏览器中，全局执行环境被认为是 window 对象，全局执行环境直到应用程序退出——例如关闭网页或浏览器——时才会被销毁；

  - 每个**函数**都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境；

  - 当代码在一个环境中执行时，会创建变量对象的一个**作用域链**（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。

  - 作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果环境是函数，则将其活动对象（activation object）作为**变量对象**。活动对象在最开始时只包含一个变量，即 arguments 对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。

  - **标识符解析**是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）

    ```js
    var color = "blue";
    function changeColor(){
     	if (color === "blue"){
     		color = "red";
     	} else {
     		color = "blue";
     	}
    }
    changeColor();
    alert("Color is now " + color); 
    ```

  - 在局部作用域中定义的变量可以在局部环境中与全局变量互换使用，每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。

    ```js
    var color = "blue";
    function changeColor(){
     	var anotherColor = "red";
     	function swapColors(){
     		var tempColor = anotherColor;
     		anotherColor = color;
     		color = tempColor;
     		// 这里可以访问 color、anotherColor 和 tempColor
     	}
     	// 这里可以访问 color 和 anotherColor，但不能访问 tempColor
     	swapColors();
    }
    // 这里只能访问 color
    changeColor(); 
    ```

  - 

- 延长作用域链

  - try-catch 语句的 catch 块：会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明

  - with 语句：会将指定的对象添加到作用域链中

    ```js
    function buildUrl() {
     	var qs = "?debug=true";
     	with(location){
     		var url = href + qs;
     	}
     	return url;
    } 
    ```

- 没有块级作用域

  - if 语句中的变量声明会将变量添加到当前的执行环境（在这里是全局环境）中

    ```js
    if (true) {
     	var color = "blue";
    }
    alert(color); //"blue" 
    ```

  - for 语句创建的变量 i 即使在 for 循环执行结束后，会存在于循环外部的执行环境中

    ```js
    for (var i=0; i < 10; i++){
     	doSomething(i);
    }
    alert(i); //10 
    ```

  - 使用 var 声明的变量会自动被添加到最接近的环境中，如果初始化变量时没有使用 var 声明，该变量会自
    动被添加到全局环境

    ```js
    function add(num1, num2) {
     	sum = num1 + num2;
     return sum;
    }
    var result = add(10, 20); //30
    alert(sum); //30
    ```

  - 查询标识符的过程：

    - 从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符

    - 如果在局部环境中找到了该标识符，搜索过程停止，变量就绪

      ```js
      var color = "blue";
      function getColor(){
       	var color = "red";
       	return color;
      }
      alert(getColor()); //"red" 
      ```

    - 如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。搜索过程将一直追溯到全局环境的变量对象

      ```js
      var color = "blue";
      function getColor(){
       	return color;
      }
      alert(getColor()); //"blue" 
      ```

    - 如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明

#### 3、垃圾收集

- 概念

  - JavaScript 具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存，开发人员不用再关心内存使用问题，所需内存的分配以及无用内存的回收完全实现了自动管理
  - 原理：找出那些不再继续使用的变量，然后释放其占用的内存，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），周期性地执行这一操作
  - 垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有两个策略。

- 标记清除

  - 最常用的垃圾收集方式，当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”
  - 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

- 引用计数

  - 不太常见的垃圾收集策略，含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存

  - 产生的问题：循环引用，指的是对象 A 中包含一个指向对象 B 的指针，而对象 B 中也包含一个指向对象 A 的引用，会导致内存得不到回收

    ```js
    function problem(){
     	var objectA = new Object();
     	var objectB = new Object();
     	objectA.someOtherObject = objectB;
     	objectB.anotherObject = objectA;
    } 
    ```

  - IE 的 JavaScript 引擎是使用标记清除策略来实现的，但JavaScript 访问的 COM（组件对象模型） 对象依然是基于引用计数策略的，涉及 COM 对象，就会存在循环引用的问题，为了避免类似这样的循环引用问题，最好是在不使用它们的时候手工断开连接

    ```js
    //由于存在这个循环引用，即使将例子中的 DOM 从页面中移除，它也永远不会被回收
    var element = document.getElementById("some_element");
    var myObject = new Object();
    myObject.element = element;
    element.someObject = myObject;
    //将变量设置为 null 意味着切断变量与它此前引用的值之间的连接
    myObject.element = null;
    element.someObject = null; 
    ```

- 性能问题

  - 垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的，在这种情况下，确定垃圾收集的时间间隔是一个非常重要的问题；
  - IE7之前的垃圾收集器是根据内存分配量运行的，具体一点说就是 256 个变量、4096 个对象（或数组）字面量和数组元素（slot）或者 64KB 的字符串，达到上述任何一个临界值，垃圾收集器就会运行，这种实现方式的问题在于，如果一个脚本中包含那么多变量，那么该脚本很可能会在其生命周期中一直保有那么多的变量，而这样一来，垃圾收集器就不得不频繁地运行；
  - IE7之后的垃圾收集器触发垃圾收集的变量分配、字面量和（或）数组元素的临界值被调整为动态修正，各项临界值在初始时相等，如果垃圾收集例程回收的内存分配量低于 15%，则变量、字面量和（或）数组元素的临界值就会加倍，如果例程回收了 85%的内存分配量，则将各种临界值重置回默认值；
  - 在有的浏览器中可以触发垃圾收集过程，但不建议这样做，在IE 中，调用 `window.CollectGarbage()`方法会立即执行垃圾收集。在 Opera 7 及更高版本中，调用 `window.opera.collect()`也会启动垃圾收集例程。

- 管理内存

  - JavaScript在进行内存管理及垃圾收集时面临的最主要的一个问题，就是分配给 Web浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是出于安全方面的考虑，目的是防止运行 JavaScript 的网页耗尽全部系统内存而导致系统崩溃，内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量，

  - 因此，确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据，一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个做法叫做**解除引用**（dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用

    ```js
    function createPerson(name){
     	var localPerson = new Object();
     	localPerson.name = name;
     	return localPerson;
    }
    var globalPerson = createPerson("Nicholas");
    // 手工解除 globalPerson 的引用
    globalPerson = null; 
    ```

  - 解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收

#### 4、总结

- JavaScript 变量可以用来保存两种类型的值：基本类型值和引用类型值。基本类型的值源自以下 5种基本数据类型：Undefined、Null、Boolean、Number 和 String。基本类型值和引用类型值具有以下特点：
  - 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；
  - 从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本；
  - 引用类型的值是对象，保存在堆内存中；
  - 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；
  - 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同
    一个对象；
- 所有变量（包括基本类型和引用类型）都存在于一个执行环境（也称为作用域）当中，这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。以下是关于执行环境的几点总结：
  - 执行环境有全局执行环境（也称为全局环境）和函数执行环境之分；
  - 每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；
  - 函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，乃至全局环境；
  - 全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据；
  - 变量的执行环境有助于确定应该何时释放内存；
- JavaScript 是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。可以对 JavaScript 的垃圾收集例程作如下总结：
  - 离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除；
  - “标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存；
  - 另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有值被引用的次数。JavaScript引擎目前都不再使用这种算法；但在 IE 中访问非原生 JavaScript 对象（如 DOM 元素）时，这种算法仍然可能会导致问题；
  - 当代码中存在循环引用现象时，“引用计数”算法就会导致问题；
  - 解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用；